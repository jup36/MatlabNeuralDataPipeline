function getHandJsKinematics( filePath ) 
%filePath = 'S:\Junchol_Data\JS2p0\WR40_081419';
%filePath = '/Volumes/Beefcake/Junchol_Data/JS2p0/WR40_081419';

%This script loads 3-d coordinates of the reaching hand and the joystick saved in 'trj3d.mat', 
% and extracts kinematics of the hand and joystick movements. The process
% comprises 1) defining baseline positions, 2) getting baseline-subtracted
% trajectories and velocities. 'trj3d.mat' has two sets of trajectories
% after stereo-triangulation with reference to the front or side cameras. 
% Joystick trajectories from the front camera tend to be more reliable, thus
% trajectories relative to front camera are used currently. 

%% load 'trj3d.mat'
cd(filePath)s
trj3d = dir('**/*trj3d.mat');
T=load(fullfile(trj3d.folder,trj3d.name),'trj3d');
clearvars trj3d
T = T.('trj3d');

hTrjF = {T(:).allPartsMedSgFronXYZ}; % all parts median and Savitzky-Golay filtered hand trajectory front cam
%hTrjS = {T(:).allPartsMedSgSideXYZ}; % all parts median and Savitzky-Golay filtered hand trajectory side cam
jsBot = {T(:).jsBSgFronXYZ}; 
jsTop = {T(:).jsTSgFronXYZ}; 

%% collect jsTime1k_Kinematics data
jsKinFile = dir(fullfile(filePath,'jsTime1k_Kinematics_VideoFiles.mat'));

if length(jsKinFile)==1
    jkv = load(fullfile(filePath,'jsTime1k_Kinematics_VideoFiles.mat'),'jsTime1k_KV'); % load jsTime1k_KV
else
    disp('Point to "jsTime1k_Kinematics_VideoFiles.mat" with the variable "jsTime1k_KV"!')
    [jsKinFileSelect,jsKinPathSelect] = uigetfile(filePath);
    jkv = load(fullfile(jsKinPathSelect,jsKinFileSelect),'jsTime1k_KV'); % load jsTime1k_KV
end

jkv = jkv.('jsTime1k_KV');
clearvars jsTime1k_KV

% sanity check if the number of trials match
if size(jkv,2)~=size(T,2)
    error('the trial numbers differ between jsTime1k_KV and trj3d!')
end

%% get the 3d-position/velocity
gmhTrj = median(cell2mat(hTrjF),2); % global median

% get trajectories relative to the global median first, the preparatory period median can be defined after isolating reach starts
medDst = @(x) sqrt(sum((x-gmhTrj).^2)); % func to get the point-by-point Dstance from the global median position

for t = 1:length(hTrjF)
    if ~isempty(hTrjF{t})
        jkv(t).hTrjF = hTrjF{t}; 
        jkv(t).hTrjDstMed = splitapply(medDst, hTrjF{t}, 1:size(hTrjF{t},2)); % point-by-point position relative to the global median
        jkv(t).hTrjVelMed = diff([jkv(t).hTrjDstMed(:,1) jkv(t).hTrjDstMed],1,2)./(4/1000);
        % find the baseline points of low velocity and short-distance from the global median
        [~,sortIhTrjDstMed]=sort(jkv(t).hTrjDstMed); % sort by distance from the global median
        nearMedLogic = zeros(1,length(jkv(t).hTrjDstMed));
        nearMedLogic(sortIhTrjDstMed(1:min(250, length(sortIhTrjDstMed))))=1; % taking points not too far from the global median excludes low-velocity points such as time spent with the limb on the JS without moving          
        lowVelLogic = abs(jkv(t).hTrjVelMed)<5; % low-velocity points 
        
        if sum(nearMedLogic & lowVelLogic)>10
            basePosM = median(hTrjF{t}(:,nearMedLogic & lowVelLogic), 2); % low velocity (<5 mm/s) points
        else
            basePosM = gmhTrj; % just take the global median points
        end
        baseDst = @(x) sqrt(sum((x-basePosM).^2)); % func to get the point-by-point Dstance from the global median position
        jkv(t).hTrjDstBase = splitapply(baseDst, hTrjF{t}, 1:size(hTrjF{t},2)); % point-by-point position relative to trial-by-trial baseline
        jkv(t).hTrjVelBase = diff([jkv(t).hTrjDstBase(:,1) jkv(t).hTrjDstBase],1,2)./(4/1000); % point-by-point velocity
        jkv(t).hTrjDstBaseXyz = hTrjF{t}-basePosM; % normalize by subtracting the median of the baseline position X, Y, Z
        jkv(t).hTrjVelBaseXyz = diff([jkv(t).hTrjDstBaseXyz(:,1) jkv(t).hTrjDstBaseXyz],1,2);
        %elseif isempty(hTrjF{t})
        %    jkv(t).hTrjDstMed = []; jkv(t).hTrjVelMed = []; jkv(t).hTrjDstBase = []; jkv(t).hTrjVelBase = []; jkv(t).hTrjDstBaseXyz = []; jkv(t).hTrjVelBaseXyz = [];
    end
end
clearvars t

%% get the hand velocity and position cut to detect reaches
vel = [jkv(:).hTrjVelBase]; % baseline normalized 1-d velocity across all time points
sortVel=sort(vel); % sort velocity data
velCut = sortVel(round(length(sortVel)*.98)); % set the 98% cutoff for the velocity data (velocity cutoff is required, since reaches are expected to occur at high velocity)

pos = [jkv(:).hTrjDstBase]; % 1-d position relative to the trial-by-trial baseline
sortPos = sort(pos); % sort position data
sortPos(sortPos<median(sortPos))=median(sortPos); % replace less-than median position values with the median position value
posCut = 10; % set the Distance cut off as 10 mm from the baseline sortPos(round(length(sortPos)*.90));

for t = 1:size(jkv,2)
    [jkv(t).hTrjRstart, jkv(t).hTrjRstop] = getReachTimesJs2p0(jkv(t).hTrjDstBase, jkv(t).hTrjVelBase, posCut, velCut);
    % posTrace= jkv(t).hTrjDstBase; velTrace= jkv(t).hTrjVelBase;
end
clearvars t

%% get the joystick trajectory
% get the valid portions of the joystick trajectories
for tr = 1:length(jsBot)
    if length(jsBot{1,tr})==length(jsTop{1,tr}) % use joystick trajectories from front cameras (more reliable)
        jsValFst = max(T(tr).jsfstPtFB, T(tr).jsfstPtFT);
        frValFst = find(T(tr).vUseFrameIdx,1,'first');
        if jsValFst>frValFst % in most cases, js valid pts are after the first valid frame
            jkv(tr).jsTrjValB = T(tr).jsBSgFronXYZ(:,jsValFst:end);
            jkv(tr).jsTrjValT = T(tr).jsTSgFronXYZ(:,jsValFst:end);
        elseif jsValFst<frValFst % in some cases, when corresponding frames started after the js positioining 
            jkv(tr).jsTrjValB = T(tr).jsBSgFronXYZ;
            jkv(tr).jsTrjValT = T(tr).jsTSgFronXYZ;
        end  
    end
end
clearvars tr

% the global median joystick coordinates to be used as reference points
gmJsTrjT = median(cell2mat({jkv(:).jsTrjValT}),2); % the global median joystick top
gmJsTrjB = median(cell2mat({jkv(:).jsTrjValB}),2); % the global median joystick bottom

medDstJsT = @(x) sqrt(sum((x-gmJsTrjT).^2)); % func to get the point-by-point Dstance from the global median position
medDstJsB = @(x) sqrt(sum((x-gmJsTrjB).^2)); % func to get the point-by-point Dstance from the global median position
for tr = 1:size(jkv,2) 
    % get the distance from the global median 
    if ~isempty(jkv(tr).jsTrjValT) && ~isempty(jkv(tr).jsTrjValB)
        % distance
        jkv(tr).jsDstValGmT = splitapply(medDstJsT, jkv(tr).jsTrjValT, 1:size(jkv(tr).jsTrjValT,2)); % point-by-point position relative to the global median; 
        jkv(tr).jsDstValGmB = splitapply(medDstJsB, jkv(tr).jsTrjValB, 1:size(jkv(tr).jsTrjValB,2));
        % velocity
        jkv(tr).jsVelValGmT = diff([jkv(tr).jsDstValGmT(:,1) jkv(tr).jsDstValGmT],1,2)./(4/1000);
        jkv(tr).jsVelValGmB = diff([jkv(tr).jsDstValGmB(:,1) jkv(tr).jsDstValGmB],1,2)./(4/1000);
    end
end
clearvars tr

jsTargetPos = unique([jkv(:).reachP1]); 
for rp = 1:length(jsTargetPos)
    tmpJsPosIdx = [jkv(:).reachP1]==jsTargetPos(rp); 
    
    % bind all position/velocity data corresponding to the current joystick position (joystick top) 
    tmpJsTrjValT = [jkv(tmpJsPosIdx).jsTrjValT]; % Js top Trj
    tmpJsVelValT = [jkv(tmpJsPosIdx).jsVelValGmT]; % Js top Vel
    tmpJsTrjValTlowVelMedT = median(tmpJsTrjValT(:,abs(tmpJsVelValT)<1),2); % Js top low-vel points median
    [jkv(tmpJsPosIdx).jsTreachPosT] = deal(tmpJsTrjValTlowVelMedT); 
    
    % bind all position/velocity data corresponding to the current joystick position (joystick bottom)
    tmpJsTrjValB = [jkv(tmpJsPosIdx).jsTrjValB]; % Js bottom Trj
    tmpJsVelValB = [jkv(tmpJsPosIdx).jsVelValGmB]; % Js bottom Vel
    tmpJsTrjValTlowVelMedB = median(tmpJsTrjValB(:,abs(tmpJsVelValB)<1),2); % Js bottom low-vel points median
    [jkv(tmpJsPosIdx).jsTreachPosB] = deal(tmpJsTrjValTlowVelMedB); 
    
end
clearvars rp tmp*

save(fullfile(filePath,'trj3d.mat'), 'jkv'); % save the raw pixel values
end
%% examine trajectories by plotting
%rewardTrs = find([jsTime1k_KV(:).rewarded]==1);
% close all;
% trI = 8;
% x = jkv(trI).hTrjF(1,:); %T(jkv(trI)).vUseFrameIdx);
% y = jkv(trI).hTrjF(2,:); %T(jkv(trI)).vUseFrameIdx);
% z = jkv(trI).hTrjF(3,:); %T(jkv(trI)).vUseFrameIdx);
% c = 1:sum(jkv(trI).vUseFrameIdx); % generate a colormap;
% 
% jsAtTarget = [jkv(trI).jsTreachPosT jkv(trI).jsTreachPosB]; % joystick at the reach target position
% jsX = jsAtTarget(1,:); % Js at the reach target position X
% jsY = jsAtTarget(2,:); % Js at the reach target position Y
% jsZ = jsAtTarget(3,:); % Js at the reach target position Z
% 
% figure; hold on; 
% %plot3(gmhTrj(1), gmhTrj(2), abs(gmhTrj(3)), 'ro')
% patch([x nan],[y nan],[z nan],[c nan],'FaceColor','none','EdgeColor','interp')
% %patch([jsX nan],[jsY nan],[jsZ nan],'FaceColor','k')
% plot3(jsX, jsY, jsZ, 'k', 'lineWidth', 3, 'alpha', 0.5)
% 
% %patch([x nan],[z nan],-[y nan],[c nan],'FaceColor','none','EdgeColor','interp')
% xlabel('X(mm)')
% ylabel('Y(mm)')
% zlabel('Z(mm)')
% 
% %patch([x nan],[z nan],abs([y nan]),[c nan],'FaceColor','none','EdgeColor','interp')
% colormap cool
% colorbar
% caxis([1 sum(jkv(trI).vUseFrameIdx)])
% print(fullfile(filePath,'Figure',sprintf('hTrjDstBaseXyz_tr#%d',trI)),'-dpdf','-painters','-bestfit');
% 

% close all;
% trI = 10;
% x = jkv(trI).hTrjDstBaseXyz(1,jkv(10).vUseFrameIdx); %T(jkv(trI)).vUseFrameIdx);
% y = jkv(trI).hTrjDstBaseXyz(2,jkv(10).vUseFrameIdx); %T(jkv(trI)).vUseFrameIdx);
% z = jkv(trI).hTrjDstBaseXyz(3,jkv(10).vUseFrameIdx); %T(jkv(trI)).vUseFrameIdx);
% c = 1:sum(jkv(trI).vUseFrameIdx); % generate a colormap;
% 
% figure;
% %plot3(gmhTrj(1), gmhTrj(2), abs(gmhTrj(3)), 'ro')
% patch([x nan],[y nan],[z nan],[c nan],'FaceColor','none','EdgeColor','interp')
% %patch([x nan],[z nan],-[y nan],[c nan],'FaceColor','none','EdgeColor','interp')
% xlabel('X(mm)')
% ylabel('Y(mm)')
% zlabel('Z(mm)')
% 
% %patch([x nan],[z nan],abs([y nan]),[c nan],'FaceColor','none','EdgeColor','interp')
% colormap cool
% colorbar
% caxis([1 sum(jkv(trI).vUseFrameIdx)])
% print(fullfile(filePath,'Figure',sprintf('hTrjDstBaseXyz_tr#%d',trI)),'-dpdf','-painters','-bestfit');


% % plot/print a trial's X, Y, Z velocity
% xt = (1:size(hTrjVelBSub{7},2))*4;
% hold on; plot(xt,hTrjVelBSub{7}(1,:)); plot(xt,hTrjVelBSub{7}(2,:)); plot(xt,hTrjVelBSub{7}(3,:)); hold off
% xlabel('Time(ms)'); ylabel('Velocity(mm/s)')
% print(fullfile(filePath,'Figure',sprintf('xyzVel_tr#%d',7)),'-dpdf','-painters','-bestfit');
% 
% % plot/print a trial's position/velocity relative to the global median
% figure; plot(xt,hTrjFDstBase{7});
% hold on;
% for ii = 1:length(reachStart)
%     plot(xt(reachStart(ii)), hTrjFDstBase{7}(reachStart(ii)),'or')
% end
% hold off;
% xlabel('Time(ms)'); ylabel('Position relative to baseline (mm)')
% print(fullfile(filePath,'Figure',sprintf('handPosRelToBaseline_tr#%d',7)),'-dpdf','-painters','-bestfit');
% 
% figure; plot(xt,hTrjFVelBase{7});
% hold on;
% for ii = 1:length(reachStart)
%     plot(xt(reachStart(ii)), hTrjFVelBase{7}(reachStart(ii)),'or')
% end
% hold off;
% xlabel('Time(ms)'); ylabel('Velocity (mm/s)')
% print(fullfile(filePath,'Figure',sprintf('handVelRelToBaseline_tr#%d',7)),'-dpdf','-painters','-bestfit');
