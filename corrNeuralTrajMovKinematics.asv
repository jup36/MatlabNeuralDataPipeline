function corrNeuralTrajMovKinematics(filePath, fileNameNeuralTrj, fileNameBeh, saveNameTag, eventMarkersRelative, timeWinOfInterest, varargin)
%corrNeuralTrajMovKinematics opens/loads the trial-by-trial neural
% population trajectories extracted using either pca or gpfa and movement kinematic 
% variables saved in the 'behvariables.mat'. The trial-by-trial neural
% population trajectories are then divided into n-folds (e.g. 4 folds) 
% that are ranked based on a movement kinematic variable - trial-by-trial 1) max position, 2) max velocity, 3) lick counts. 
%

%filePath = 'Z:\parkj\NeuralData\ITphys\IT01_Ldms_M1_121317\Matfiles';
cd(filePath)
%fileNameNeuralTrj = 'IT01Str_121317_pca_reward_5D_50msBin.mat';
%fileNameBeh = 'BehVariables.mat';

%% load/organize neural trjectories pca- or gpfa-based
neuralTrajFile = dir(fullfile(filePath,fileNameNeuralTrj));
load(neuralTrajFile.name,'pcaResult') 
nTrj.trjMat = reshape([pcaResult.kern.seqTrain.xpost], pcaResult.p.Results.pcaDim, [], length(pcaResult.kern.seqTrain)); % neural trajectories in dim x timeBins x trials (e.g. 5x100x114)
nTrj.trialId = [pcaResult.kern.seqTrain.trialId]; % trial IDs for the neural trjectories
nTrj.relativeTimeBins = pcaResult.p.Results.timeRange(1):pcaResult.p.Results.pcaBinSize:pcaResult.p.Results.timeRange(2)-pcaResult.p.Results.pcaBinSize; % get timeBins relative to time 0 (e.g. reward) of the current PSTH
binsOfInt = nTrj.relativeTimeBins>=timeWinOfInterest(1) & nTrj.relativeTimeBins<timeWinOfInterest(2); % the time bins of interest for the behavioral kinematics (e.g. when reaches are most likely to occur) to narrow down the range of behavioral measures

%% load/organize behavioral data 'BehVariables.mat'
behFile = dir(fullfile(filePath,fileNameBeh));
load(behFile.name, 'ts', 'reach0','lick')
behTS = ts.reward(nTrj.trialId); % nTrj.trialId (*seqTrain.trialId) contains non-NaN trials only
lickBin = zeros(1,length(lick)); % licks
lickBin(ts.lick) = 1; % licks

for t = 1:length(behTS) % increment trials, take the trial-by-trial position/velocity data and bin them to match the neural trjectories (e.g. 50 ms)
    timeWin = behTS(t)+pcaResult.p.Results.timeRange; % the time window, e.g. -3 to 2 sec relative to the behavioral timestamp
    bTrj(t).reachPos = smooth(decimate(reach0(timeWin(1):timeWin(2)-1),pcaResult.p.Results.pcaBinSize),3)'; % get decimated behavioral trjectories on the same timescale of the neural trjectories
    bTrj(t).reachVel = smooth(diff([bTrj(t).reachPos(1) bTrj(t).reachPos]),3)'; % get reach velocities (from reach0)
    %bTrj(t).xPos = smooth(decimate(Xpos(timeWin(1):timeWin(2)-1),pcaResult.p.Results.pcaBinSize),3)'; % x positions
    %bTrj(t).yPos = smooth(decimate(Ypos(timeWin(1):timeWin(2)-1),pcaResult.p.Results.pcaBinSize),3)'; % y positions
    bTrj(t).maxReachPos = max(bTrj(t).reachPos(binsOfInt)); % max reach position within the time window of interest
    bTrj(t).maxReachVel = max(bTrj(t).reachVel(binsOfInt)); % max reach velocity within the time window of interest
    bTrj(t).trialId = t;
    bTrj(t).lick = bin1msSpkCountMat(lickBin(timeWin(1):timeWin(2)-1),pcaResult.p.Results.pcaBinSize,pcaResult.p.Results.pcaBinSize);
    bTrj(t).lickCount =  sum(bTrj(t).lick); %
end
clearvars t

%% correlation between neural population trjectories and movement kinematics
for dim = 1:size(nTrj.trjMat,1) % increment dimensions
    trialByTimePCscore =  squeeze(nTrj.trjMat(dim,:,:))'; % get the trial-by-timeBin PC score matrix for the current dimension
    % correlation movement kinematics & neural trjectories
    [rMaxPos(:,dim),pPos(:,dim)] = corr(trialByTimePCscore,[bTrj.maxReachPos]'); % correlation between PC score in the current dim across all time bins and maxReachPos
    [rMaxVel(:,dim),pVel(:,dim)] = corr(trialByTimePCscore,[bTrj.maxReachVel]'); % correlation between PC score in the current dim across all time bins and maxReachVel
    [rPosBbyBtotal,pPosBbyBtotal] = corr(trialByTimePCscore,reshape([bTrj.reachPos]',[],length(behTS))');  % correlation between PC score in the current dim across all time bins and timeBin-by-timeBin reachPos
    rPosBbyB(:,dim) = diag(rPosBbyBtotal); % take rho of the matching time bins
    pPosBbyB(:,dim) = diag(pPosBbyBtotal); % take pVal of the matching time bins
    [rVelBbyBtotal,pVelBbyBtotal] = corr(trialByTimePCscore,reshape([bTrj.reachVel]',[],length(behTS))');  % corr timeBin-by-timeBin
    rVelBbyB(:,dim) = diag(rVelBbyBtotal); % take rho of the matching time bins
    pVelBbyB(:,dim) = diag(pVelBbyBtotal); % take pVal of the matching time bins
    % correlation lick counts & neural trjectories
    [rLick(:,dim),pLick(:,dim)] = corr(trialByTimePCscore,[bTrj.lickCount]'); % correlation between the current
end
clearvars dim

cmap = TNC_CreateRBColormap(100,'rb'); % generate a colormap for imagesc psth
figure; imagescJP(rMaxPos',cmap,[-0.8 0.8]); pbaspect([1 1 1]); colorbar; title('') % plot the corr between nTrj and maxPos dim-by-dim
print;
figure; imagescJP(rMaxVel',cmap,[-0.8 0.8]); pbaspect([1 1 1]); colorbar; title('') % plot the corr between nTrj and maxVel dim-by-dim
print;
figure; imagescJP(rLick',cmap,[-0.8 0.8]); pbaspect([1 1 1]); colorbar; title('')   % plot the corr between nTrj and lickCount dim-by-dim
prints;

%% plot rank-folded neural population trajectories
% plot principal components
%plot(pcaResult.kern.estParams.L(:,1)) % the 1st principal component
plotEachDimVsTime(pcaResult.kern.seqTrain, 'xpost', pcaResult.binWidth);

% plot trajectories
trFolds = floor(length(bTrj)/folds); % trial folds
sortMaxPos = sortrows([[bTrj.maxReachPos];[bTrj.trialId]]',-1); % sorted max reach positions in a descending order
sortMaxVel = sortrows([[bTrj.maxReachVel];[bTrj.trialId]]',-1); % sorted max reach velocities
sortLickCnt = sortrows([[bTrj.lickCount];[bTrj.trialId]]',-1);  % sorted trial lick counts

for f = 0:folds-1
    if f<folds-1
        nTrj.sortedFoldMaxPos{f+1} = nTrj.trjMat(:,:,sortMaxPos(f*trFolds+1:(f+1)*trFolds,2)); % take the trials of the current fold sorted by the max position
        nTrj.sortedFoldMaxVel{f+1} = nTrj.trjMat(:,:,sortMaxVel(f*trFolds+1:(f+1)*trFolds,2)); % take the trials of the current fold sorted by the max velocity
        nTrj.sortedFoldLickCnt{f+1} = nTrj.trjMat(:,:,sortLickCnt(f*trFolds+1:(f+1)*trFolds,2)); % take the trials of the current fold sorted by the lick counts
    elseif f==folds-1 % take all the remaining trials for the final fold
        nTrj.sortedFoldMaxPos{f+1} = nTrj.trjMat(:,:,sortMaxPos(f*trFolds+1:end,2)); % take the trial-aver the current fold sorted by the max position
        nTrj.sortedFoldMaxVel{f+1} = nTrj.trjMat(:,:,sortMaxVel(f*trFolds+1:end,2)); % take the trial-average within the current fold sorted by the max velocity
        nTrj.sortedFoldLickCnt{f+1} = nTrj.trjMat(:,:,sortLickCnt(f*trFolds+1:end,2)); % take the trial-average within the current fold sorted by the lick counts
    end
end

eventMarkers = [1, arrayfun(@(x) find(x==nTrj.relativeTimeBins), eventMarkersRelative)]; % find the time bins corresponding to the event markers using the relative eventMarkers (e.g. [-1050 0]) given as the input
neuralTrajCmap  = summer(folds); % get the colormap for fold-by-fold trial-averaged neural trajectories
eventMarkerCmap = cool(length(eventMarkers)+1); % get the colormap for all the events to be marked

nTrj.trAvgSortedFoldMaxPos = cellfun(@(x) nanmean(x(1:3,:,:),3), nTrj.sortedFoldMaxPos, 'UniformOutput', false); % 



%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NESTED HELPER FUNCTIONS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
    function plot3DneuralTrajAndEventMarkers( neuralTrajCell, neuralTrajCmap, eventMarkers, eventMarkerCmap )
        figure; 
        hold on;
        for fd = 1:length(neuralTrajCell)
            plot3(neuralTrajCell{fd}(1,:),neuralTrajCell{fd}(2,:),neuralTrajCell{fd}(3,:),'LineWidth',2,'color',neuralTrajCmap(fd,:))
            for evt = 1:length(eventMarkers)
                plot3(neuralTrajCell{fd}(1,eventMarkers(evt)),neuralTrajCell{fd}(2,eventMarkers(evt)),neuralTrajCell{fd}(3,eventMarkers(evt)),'o','MarkerSize',10, 'MarkerFaceColor',eventMarkerCmap(evt,:), 'MarkerEdgeColor',eventMarkerCmap(evt,:));
                plot3(neuralTrajCell{fd}(1,eventMarkers(evt)),neuralTrajCell{fd}(2,eventMarkers(evt)),neuralTrajCell{fd}(3,eventMarkers(evt)),'o','MarkerSize',10, 'MarkerFaceColor',eventMarkerCmap(evt,:), 'MarkerEdgeColor',eventMarkerCmap(evt,:));
                plot3(neuralTrajCell{fd}(1,eventMarkers(evt)),neuralTrajCell{fd}(2,eventMarkers(evt)),neuralTrajCell{fd}(3,eventMarkers(evt)),'o','MarkerSize',10, 'MarkerFaceColor',eventMarkerCmap(evt,:), 'MarkerEdgeColor',eventMarkerCmap(evt,:));
            end
        end
        hold off;
        pbaspect([1 1 1]); grid on;
    end

    function p = parse_input_corrNeuralTrajMovKinematics( filePath, fileName, saveNameTag, vargs ) % note that a nested function must use vargs not varargin when varargin was used for the main function
        
        %parse input, and extract name-value pairs for the main function 'corrNeuralTrajMovKinematics.m'
        
        default_trialFolds = 4; % # of folds to classify the total trials by the rank of a behavioral variable
        default_lineWidth = 2;  % default lineWidth to be used to plot the neural trajectories 
        
        p = inputParser; % create parser object
        addRequired(p,'filePath'); % file directory
        addRequired(p,'fileNameNeuralTrj'); % fileName for neural population trajectories
        addRequired(p,'fileNameBeh'); % fileName for movement kinematic variables
        addRequired(p,'saveNameTag'); % saveName used to save the outcomes
        addRequired(p,'eventMarkers'); % timing for specific events to be marked on each neural trajectory
        
        addParameter(p,'frHighPass', default_frHighPass)
        addParameter(p,'frLowPass', default_frLowPass) % FR high cut might not be necessary
        addParameter(p,'timeRange', default_timeRange)
        addParameter(p,'pcaBinSize', default_pcaBinSize)
        addParameter(p,'pcaDim', default_pcaDim)
        addParameter(p,'pcaKernSD', default_pcaKernSD)
        addParameter(p,'fullCrossVal', default_fullCrossVal)
        addParameter(p,'xcorThresholdPer', default_xcorThresholdPer)
        addParameter(p,'crossValFolds', default_crossValFolds)
        
        parse(p, filePath, fileName, saveNameTag, vargs{:})
        
    end

end

